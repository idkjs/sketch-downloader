{"data":{"note":[{"id":"nerP3hkOxX6sMVvVUtBIbs","title":"Phantom Types in ReasonML","data":{"lang": "RE", "links": [], "blocks": [{"id": "zp6id1XrzWmekwB5WVbLD0", "data": {"kind": "text", "value": "\n### Introduction\n\n*\"A phantom type is a parametrised type whose parameters do not all appear on the right-hand side of its definition...\"*\n[Haskell Wiki, PhantomType](https://wiki.haskell.org/Phantom_type)\n\nThe following write-up is intended as an introduction into using phantom types in **ReasonML**.\n\nTaking a look at the above definition from the Haskell wiki, it states that phantom types are parametrised types where not all parameters appear on the right-hand side. Let's try to see if we can implement a similar example as in said wiki.\n\n\n### Example"}, "deleted": false}, {"id": "WMCw3y2UPVDC0ObjMM2I1w", "data": {"kind": "text", "value": "```reason\ntype formData('a) = string;\n```\n\nSo `formData` is a phantom type as the `'a` parameter only appears on the left side.\n\nLet's create a file `FormData.rei` to define the `formData` interface and add the above definition.\n\nWe want to enable a library user to create a `formData` type. What we also want is to restrict the type in certain parts of the library. For example we want to be able to differentiate between *validated* und *unvalidated* form data. So let's add two type definitions `validated` and `unvalidated` to our `FormData.rei` file."}, "deleted": false}, {"id": "WqeSNLShwTGK63mrFd99lV", "data": {"kind": "code", "value": "module type FormData = {\n  type formData('a);\n  type validated;\n  type unvalidated;\n };"}, "deleted": false}, {"id": "oxpVhMVeXvpPIOeZk9z1gs", "data": {"kind": "text", "value": "Nothing special up until here, just two lone type definitions.\nNext we would want to expose a function that receives a string and returns an unvalidated `formData` type, which we will do by extending our API."}, "deleted": false}, {"id": "TlIQbl3wmoj7bPG7T8rCwH", "data": {"kind": "code", "value": "module type FormData = {\n  type formData('a);\n  type validated;\n  type unvalidated;\n  let formData: string => formData(unvalidated);\n};"}, "deleted": false}, {"id": "ECdGRpBFGThfcaGDdEP6yd", "data": {"kind": "text", "value": "And maybe we want to add an `upperCase` function that does exactly that, take a unvalidated input and return an unvalidated input, so again let's update our API."}, "deleted": false}, {"id": "LlGwbpYaEVgPPvlApH9Su5", "data": {"kind": "code", "value": "module type FormData = {\n  type formData('a);\n  type validated;\n  type unvalidated;\n  let formData: string => formData(unvalidated);\n  let upperCase: formData(unvalidated) => formData(unvalidated);\n};"}, "deleted": false}, {"id": "IHHvcj1Jai1vMPyu1qLZa6", "data": {"kind": "text", "value": "Finally let's also add a `validate` function that either returns nothing or the validated input."}, "deleted": false}, {"id": "P8IaaqXu8DoKqLENb1uJkC", "data": {"kind": "code", "value": "type option('a) =\n  | Some('a)\n  | None;\n\nmodule type FormData = {\n  type formData('a);\n  type validated;\n  type unvalidated;\n  let formData: string => formData(unvalidated);\n  let upperCase: formData(unvalidated) => formData(unvalidated);\n  let validate: formData(unvalidated) => option(formData(validated));\n};\n"}, "deleted": false}, {"id": "fNuY6irJzXpuqj8JbWNMmb", "data": {"kind": "text", "value": "Next, we'll create a new file and name it `FormData.re`, where we will implement the interface."}, "deleted": false}, {"id": "7LFy3dBEuuhpHLYmzGqIAa", "data": {"kind": "code", "value": "module FormData : FormData = {\n  type formData('a) = string;\n  type validated;\n  type unvalidated;\n  let formData = a => a;\n  let upperCase = a => String.uppercase_ascii(a);\n  let validate = a =>\n    if (String.length(a) > 3) {\n      Some(a);\n    } else {\n      None;\n    };\n};"}, "deleted": false}, {"id": "S5z84wnwxNV2JvxhsRQshd", "data": {"kind": "text", "value": "Let's try to use the library:"}, "deleted": false}, {"id": "BJgTackveYkDT2q3Im0qaQ", "data": {"kind": "code", "value": "open FormData;\n\nlet initialData: formData(unvalidated) = FormData.formData(\"test\");\nlet validatedData: option(formData(validated)) = validate(initialData);\n"}, "deleted": false}, {"id": "5xM9HBhmhllTViEaOqprAj", "data": {"kind": "text", "value": "So we can see that this works as expected. We validate \"test\" and get the validated form input in return. But what if we wanted to call the `upperCase` function?"}, "deleted": false}, {"id": "QtxbaszZID5nguNm93jJTX", "data": {"kind": "code", "value": "/* Uncomment to see the error! */\n/*switch (validatedData) {\n| Some(result) => FormData.upperCase(result)\n| None => a\n};*/"}, "deleted": false}, {"id": "44X5eiaC37yioJLSrjrlHf", "data": {"kind": "text", "value": "The compiler will complain:\n\n```\nError: This expression has type FormData.formData(FormData.validated) \n       but an expression was expected of type\n         FormData.formData(FormData.unvalidated)\n       Type FormData.validated is not compatible with type\n         FormData.unvalidated\n```\n\n\nSo we can't pass in a validated input into `upperCase`, but calling the same function with an unvalidated input will work. We can already see the benefits."}, "deleted": false}, {"id": "SybcQLcEjT8zRS9jEtOVGP", "data": {"kind": "code", "value": "FormData.upperCase(initialData);"}, "deleted": false}, {"id": "7aTORKGNz9RzVM3T4nnt6u", "data": {"kind": "text", "value": "This is all interesting but what if somebody wants to bypass the validation and by simply creating a *validated* type?"}, "deleted": false}, {"id": "6aZDqyJoe0Ti5dqtM62LSx", "data": {"kind": "code", "value": "/* Uncomment to see the error! */\n/* \nlet byPassValidation: string => formData(validated) = a => a;\n*/"}, "deleted": false}, {"id": "H425RI3iFAmlyVeoj0CrjW", "data": {"kind": "text", "value": "The compiler will display an error:\n\n```\nError: This expression has type string but an expression was expected of type\n         FormData.formData(FormData.validated)\n```"}, "deleted": false}, {"id": "yfsJIMzIUDzHXZrc8yJCCN", "data": {"kind": "text", "value": "If you recall we defined the type `formData` inside the interface as follows:\n\n```reason\ntype formData('a);\n```\n\nBy taking this approach, we're hiding the implementation, to prevent a library user to arbitrarily bypass any internals. This important. Because we chose to define the `formData` type inside the interface definition user land could simply bypass the validation.\n\n```reason\nlet byPassValidation: string => formData(validated) = a => a;\n```\n\nThe above example would work, if you would expose the type definition inside the interface.\n\n\nFinally, what would happen when we try validate our previously validated input?"}, "deleted": false}, {"id": "kor2I7PNVmu7pwpcezMsHm", "data": {"kind": "code", "value": "/* Uncomment to see the error! */\n/*switch (validatedData) {\n| Some(result) => FormData.upperCase(result)\n| None => a\n}*/"}, "deleted": false}, {"id": "nSTpEExolrxHmY9CWoIQ1c", "data": {"kind": "text", "value": "Again we receive the appropriate error message:\n\n```\nError: This expression has type FormData.formData(FormData.validated)\n       but an expression was expected of type\n         FormData.formData(FormData.unvalidated)\n       Type FormData.validated is not compatible with typw\n       \t FormData.unvalidated\n```"}, "deleted": false}, {"id": "QMkf68JkxnFI9r5dudt4nW", "data": {"kind": "text", "value": "\n### Summary\nWith phantom types we can enforce specific types to user land without exposing how these can be constructed.\nThis opens up a number of possible opportunities we can leverage, i.e. guaranteeing a value is `> 100` throughout our application.\n\nCheck the original gist [here](https://gist.github.com/busypeoples/3a28d039272ec3eb33ca2fc6b32dafc7)\n\nIf you have feedback, insights or questions: [@twitter](https://twitter.com/sharifsbeat)"}, "deleted": false}]}}]}}